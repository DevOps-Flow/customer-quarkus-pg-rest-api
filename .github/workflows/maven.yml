name: Release Native • Multi-jobs (Build, Image, Push & ArgoCD Sync + Rollback)

on:
  push:
    branches: [ master ]
  workflow_dispatch:

permissions:
  contents: write
  packages: write

concurrency:
  group: release-native-${{ github.ref }}
  cancel-in-progress: false

env:
  # Mantida como no pipeline original (repo variable). Ex.: ivanc/customer-quarkus-pg-rest-api
  DOCKER_IMAGE: ${{ vars.DOCKER_IMAGE }}

jobs:
  meta:
    name: Meta • Versão e nome da imagem
    runs-on: ubuntu-latest
    outputs:
      VERSION: ${{ steps.ver.outputs.VERSION }}
      IMAGE:   ${{ steps.img.outputs.IMAGE }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      - name: Setup Maven 3.9.9
        uses: stCarolas/setup-maven@v5
        with:
          maven-version: 3.9.9

      - name: Extract project version from pom.xml
        id: ver
        run: |
          VERSION=$(mvn -q -DforceStdout help:evaluate -Dexpression=project.version)
          echo "VERSION=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Project version: $VERSION"

      # Mantém a lógica já validada: usa DOCKER_IMAGE (repo var) se existir; caso contrário, <dockerhub_username>/<repo>
      - name: Decide image name (robusto + validação)
        id: img
        env:
          REPO_NAME: ${{ github.event.repository.name }}
          IMAGE_INPUT: ${{ env.DOCKER_IMAGE }}                # repo var (pode vir vazia)
          DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}   # precisa estar configurado
        run: |
          set -euo pipefail

          if [ -n "${IMAGE_INPUT:-}" ]; then
            IMAGE="$IMAGE_INPUT"
          elif [ -n "${DOCKERHUB_USER:-}" ]; then
            IMAGE="${DOCKERHUB_USER}/${REPO_NAME}"
          else
            echo "ERRO: Nome da imagem vazio."
            echo "Defina a repo variable DOCKER_IMAGE (ex.: meuuser/minhaimg) OU o secret DOCKERHUB_USERNAME."
            exit 1
          fi

          # valida formato docker simples (evita ':tag' sem repo)
          if ! echo "$IMAGE" | grep -Eq '^[a-z0-9]+([._-][a-z0-9]+)*/[a-z0-9]+([._-][a-z0-9]+)*$'; then
            echo "ERRO: Nome de imagem inválido: '$IMAGE'"
            echo "Use algo como 'usuario/repo' (somente minúsculas, dígitos, '.', '_', '-')."
            exit 1
          fi

          echo "IMAGE=$IMAGE" >> "$GITHUB_OUTPUT"
          echo "Imagem alvo resolvida: $IMAGE"

  build_native:
    name: Build • Quarkus Native
    runs-on: ubuntu-latest
    needs: [meta]
    steps:
      - uses: actions/checkout@v4

      - name: Cache Maven repo
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2-

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      - name: Setup Maven 3.9.9
        uses: stCarolas/setup-maven@v5
        with:
          maven-version: 3.9.9

      # ===== BUILD NATIVO (UMA ÚNICA VEZ) =====
      - name: Build Quarkus Native (container-build)
        run: mvn -B -ntp package -Pnative -Dquarkus.native.container-build=true

      - name: Upload native runner
        uses: actions/upload-artifact@v4
        with:
          name: native-runner
          path: target/*-runner
          if-no-files-found: error

  image:
    name: Docker • Build & Push (com cache remoto)
    runs-on: ubuntu-latest
    needs: [build_native, meta]
    steps:
      - uses: actions/checkout@v4

      - name: Download native runner
        uses: actions/download-artifact@v4
        with:
          name: native-runner
          path: target

      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker Hub login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Fallback local: mesmo que o job meta não exporte, resolvemos IMAGE aqui
      - name: Resolve IMAGE efetivo (fallback robusto)
        id: eff
        env:
          META_IMAGE: ${{ needs.meta.outputs.IMAGE }}
          VAR_IMAGE: ${{ env.DOCKER_IMAGE }}
          DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          set -euo pipefail
          IMAGE="${META_IMAGE:-}"
          if [ -z "${IMAGE}" ]; then
            if [ -n "${VAR_IMAGE:-}" ]; then
              IMAGE="${VAR_IMAGE}"
            elif [ -n "${DOCKERHUB_USER:-}" ]; then
              IMAGE="${DOCKERHUB_USER}/${REPO_NAME}"
            fi
          fi
          if [ -z "${IMAGE}" ]; then
            echo "ERRO: IMAGE efetivo vazio. Defina vars.DOCKER_IMAGE ou DOCKERHUB_USERNAME."
            exit 1
          fi
          # valida formato simples
          if ! echo "$IMAGE" | grep -Eq '^[a-z0-9]+([._-][a-z0-9]+)*/[a-z0-9]+([._-][a-z0-9]+)*$'; then
            echo "ERRO: Nome de imagem inválido: '$IMAGE'"
            exit 1
          fi
          echo "IMAGE=${IMAGE}" >> "$GITHUB_OUTPUT"
          echo "IMAGE efetivo: ${IMAGE}"

      - name: Sanity • Conferir IMAGE e VERSION
        run: |
          set -euo pipefail
          echo "IMAGE='${{ steps.eff.outputs.IMAGE }}'"
          echo "VERSION='${{ needs.meta.outputs.VERSION }}'"
          test -n "${{ steps.eff.outputs.IMAGE }}"   || (echo "IMAGE vazio" && exit 1)
          test -n "${{ needs.meta.outputs.VERSION }}" || (echo "VERSION vazia" && exit 1)

      - name: Build & Push image (version + latest)
        id: dkr
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.native
          push: true
          tags: |
            ${{ steps.eff.outputs.IMAGE }}:${{ needs.meta.outputs.VERSION }}
            ${{ steps.eff.outputs.IMAGE }}:latest
          build-args: |
            APP_VERSION=${{ needs.meta.outputs.VERSION }}
          cache-from: type=registry,ref=${{ steps.eff.outputs.IMAGE }}:buildcache
          cache-to:   type=registry,ref=${{ steps.eff.outputs.IMAGE }}:buildcache,mode=max

  update_manifest:
    name: GitOps • Atualizar imagem no manifesto
    runs-on: ubuntu-latest
    needs: [image, meta]
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4

      # Mesmo fallback local para garantir IMAGE
      - name: Resolve IMAGE efetivo (fallback robusto)
        id: eff
        env:
          META_IMAGE: ${{ needs.meta.outputs.IMAGE }}
          VAR_IMAGE: ${{ env.DOCKER_IMAGE }}
          DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          set -euo pipefail
          IMAGE="${META_IMAGE:-}"
          if [ -z "${IMAGE}" ]; then
            if [ -n "${VAR_IMAGE:-}" ]; then
              IMAGE="${VAR_IMAGE}"
            elif [ -n "${DOCKERHUB_USER:-}" ]; then
              IMAGE="${DOCKERHUB_USER}/${REPO_NAME}"
            fi
          fi
          if [ -z "${IMAGE}" ]; then
            echo "ERRO: IMAGE efetivo vazio para update_manifest."
            exit 1
          fi
          if ! echo "$IMAGE" | grep -Eq '^[a-z0-9]+([._-][a-z0-9]+)*/[a-z0-9]+([._-][a-z0-9]+)*$'; then
            echo "ERRO: Nome de imagem inválido: '$IMAGE'"
            exit 1
          fi
          echo "IMAGE=${IMAGE}" >> "$GITHUB_OUTPUT"
          echo "IMAGE efetivo: ${IMAGE}"

      - name: Update deployment image reference (yq)
        env:
          IMAGE:   ${{ steps.eff.outputs.IMAGE }}
          VERSION: ${{ needs.meta.outputs.VERSION }}
        run: |
          set -euo pipefail
          IMG="${IMAGE}:${VERSION}"
          echo "Atualizando imagem em k8s/20-deployment-service.yaml -> ${IMG}"
          export IMG  # <<< o pulo do gato

          mkdir -p "$HOME/.local/bin"
          curl -fsSL -o "$HOME/.local/bin/yq" \
            https://github.com/mikefarah/yq/releases/download/v4.44.1/yq_linux_amd64
          chmod +x "$HOME/.local/bin/yq"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

          "$HOME/.local/bin/yq" -i '
            (. | select(.kind=="Deployment" and .metadata.name=="customer-api")
              .spec.template.spec.containers[]
              | select(.name=="customer-api")).image = env(IMG)
          ' k8s/20-deployment-service.yaml

          NEW_IMAGE=$("$HOME/.local/bin/yq" '
            (. | select(.kind=="Deployment" and .metadata.name=="customer-api")
              .spec.template.spec.containers[]
              | select(.name=="customer-api")).image
          ' k8s/20-deployment-service.yaml)

          test -n "${NEW_IMAGE}" || (echo "ERRO: imagem vazia após yq." && exit 1)
          echo "Imagem final no manifesto: ${NEW_IMAGE}"

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add k8s/20-deployment-service.yaml
          git commit -m "deploy: update image -> ${IMG} [skip ci]" || echo "Sem alterações para commitar."
          git fetch origin master
          git pull --rebase origin master
          git push


  argocd_sync:
    name: Argo CD • Sync + Wait (com rollback)
    runs-on: ubuntu-latest
    needs: [image, update_manifest]
    env:
      ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
      ARGOCD_TOKEN:  ${{ secrets.ARGOCD_TOKEN }}
      ARGOCD_APP:    ${{ secrets.ARGOCD_APP }}
    steps:
      - name: Verificar vars do ArgoCD
        run: |
          test -n "${ARGOCD_SERVER}" || (echo "ARGOCD_SERVER não definido" && exit 1)
          test -n "${ARGOCD_TOKEN}"  || (echo "ARGOCD_TOKEN não definido" && exit 1)
          test -n "${ARGOCD_APP}"    || (echo "ARGOCD_APP não definido" && exit 1)

      - name: Argo CD sync (pode falhar)
        id: argocd-sync
        continue-on-error: true
        env:
          VER: v2.13.3
        run: |
          set -euo pipefail
          echo "Iniciando sincronização do ArgoCD…"
          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app get "$ARGOCD_APP" --refresh'

          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app sync "$ARGOCD_APP" --prune --timeout 600'

          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app wait "$ARGOCD_APP" --health --timeout 600'

      - name: Rollback on failure (git revert + Argo CD sync)
        if: steps.argocd-sync.outcome == 'failure'
        env:
          VER: v2.12.3
        run: |
          set -euo pipefail
          echo "⚠️ Deploy falhou — iniciando rollback GitOps…"

          git fetch origin master
          git checkout master
          git pull --rebase origin master

          LAST_COMMIT=$(git rev-parse HEAD)
          echo "Revertendo commit: ${LAST_COMMIT}"
          git revert --no-edit "${LAST_COMMIT}" || true
          git push

          echo "Sincronizando Argo CD para aplicar o rollback…"
          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app get "$ARGOCD_APP" --refresh'

          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app sync "$ARGOCD_APP" --timeout 600'

          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app wait "$ARGOCD_APP" --health --timeout 600'

          echo "✅ Rollback concluído com sucesso."
