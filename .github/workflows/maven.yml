name: Release Native • Multi-jobs (Build, Image, Push & ArgoCD Sync + Rollback)

on:
  push:
    branches: [ master ]
  workflow_dispatch:

permissions:
  contents: write
  packages: write

concurrency:
  group: release-native-${{ github.ref }}
  cancel-in-progress: false

env:
  DOCKER_IMAGE: ${{ vars.DOCKER_IMAGE }} # mantém a variável existente

jobs:
  meta:
    name: Meta • Versão e nome da imagem
    runs-on: ubuntu-latest
    outputs:
      VERSION: ${{ steps.ver.outputs.VERSION }}
      IMAGE:   ${{ steps.img.outputs.IMAGE }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      - name: Setup Maven 3.9.9
        uses: stCarolas/setup-maven@v5
        with:
          maven-version: 3.9.9

      - name: Extract project version from pom.xml
        id: ver
        run: |
          VERSION=$(mvn -q -DforceStdout help:evaluate -Dexpression=project.version)
          echo "VERSION=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Project version: $VERSION"

      - name: Decide image name
        id: img
        env:
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          if [ -n "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
            IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/${REPO_NAME}"
          else
            IMAGE="${{ env.DOCKER_IMAGE }}"
          fi
          echo "IMAGE=$IMAGE" >> "$GITHUB_OUTPUT"
          echo "Imagem alvo: $IMAGE"

  build_native:
    name: Build • Quarkus Native
    runs-on: ubuntu-latest
    needs: [meta]
    steps:
      - uses: actions/checkout@v4

      - name: Cache Maven repo
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2-

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'
          cache: maven

      - name: Setup Maven 3.9.9
        uses: stCarolas/setup-maven@v5
        with:
          maven-version: 3.9.9

      # ===== BUILD NATIVO (UMA ÚNICA VEZ) =====
      - name: Build Quarkus Native (container-build)
        run: mvn -B -ntp package -Pnative -Dquarkus.native.container-build=true

      - name: Upload native runner
        uses: actions/upload-artifact@v4
        with:
          name: native-runner
          path: target/*-runner
          if-no-files-found: error

  image:
    name: Docker • Build & Push (com cache remoto)
    runs-on: ubuntu-latest
    needs: [build_native, meta]
    steps:
      - uses: actions/checkout@v4

      - name: Download native runner
        uses: actions/download-artifact@v4
        with:
          name: native-runner
          path: target

      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker Hub login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build & Push image (version + latest)
        id: dkr
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.native
          push: true
          tags: |
            ${{ needs.meta.outputs.IMAGE }}:${{ needs.meta.outputs.VERSION }}
            ${{ needs.meta.outputs.IMAGE }}:latest
          build-args: |
            APP_VERSION=${{ needs.meta.outputs.VERSION }}
          cache-from: type=registry,ref=${{ needs.meta.outputs.IMAGE }}:buildcache
          cache-to:   type=registry,ref=${{ needs.meta.outputs.IMAGE }}:buildcache,mode=max

  update_manifest:
    name: GitOps • Atualizar imagem no manifesto
    runs-on: ubuntu-latest
    needs: [image, meta]
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4

      - name: Update deployment image reference (early, tag legível)
        env:
          IMAGE:   ${{ needs.meta.outputs.IMAGE }}
          VERSION: ${{ needs.meta.outputs.VERSION }}
        run: |
          set -euo pipefail
          if [ -z "${IMAGE}" ] || [ -z "${VERSION}" ]; then
            echo "ERRO: IMAGE ou VERSION vazias."
            exit 1
          fi

          IMG="${IMAGE}:${VERSION}"
          export IMG
          echo "Atualizando imagem em k8s/20-deployment-service.yaml -> ${IMG}"

          # yq local
          mkdir -p "$HOME/.local/bin"
          curl -fsSL -o "$HOME/.local/bin/yq" \
            https://github.com/mikefarah/yq/releases/download/v4.44.1/yq_linux_amd64
          chmod +x "$HOME/.local/bin/yq"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

          # Atualiza a imagem (Deployment/Container: customer-api)
          "$HOME/.local/bin/yq" -i '
            (. | select(.kind=="Deployment" and .metadata.name=="customer-api")
              .spec.template.spec.containers[]
              | select(.name=="customer-api")).image = env(IMG)
          ' k8s/20-deployment-service.yaml

          # Sanity check: garante que a imagem não ficou vazia
          NEW_IMAGE=$("$HOME/.local/bin/yq" '
            (. | select(.kind=="Deployment" and .metadata.name=="customer-api")
              .spec.template.spec.containers[]
              | select(.name=="customer-api")).image
          ' k8s/20-deployment-service.yaml)

          if [ -z "${NEW_IMAGE}" ]; then
            echo "ERRO: imagem ficou vazia após o yq. Abortando."
            exit 1
          fi
          echo "Imagem final no manifesto: ${NEW_IMAGE}"

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add k8s/20-deployment-service.yaml
          git commit -m "deploy: update image -> ${IMAGE}:${VERSION} [skip ci]" || echo "Sem alterações para commitar."
          git fetch origin master
          git pull --rebase origin master
          git push

  argocd_sync:
    name: Argo CD • Sync + Wait (com rollback)
    runs-on: ubuntu-latest
    needs: [image, update_manifest]
    env:
      ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
      ARGOCD_TOKEN:  ${{ secrets.ARGOCD_TOKEN }}
      ARGOCD_APP:    ${{ secrets.ARGOCD_APP }}
    steps:
      - name: Verificar vars do ArgoCD
        run: |
          test -n "${ARGOCD_SERVER}" || (echo "ARGOCD_SERVER não definido" && exit 1)
          test -n "${ARGOCD_TOKEN}"  || (echo "ARGOCD_TOKEN não definido" && exit 1)
          test -n "${ARGOCD_APP}"    || (echo "ARGOCD_APP não definido" && exit 1)

      # 1) Tenta sincronizar (se falhar, o job continua e o próximo step faz rollback)
      - name: Argo CD sync (pode falhar)
        id: argocd-sync
        continue-on-error: true
        env:
          VER: v2.13.3
        run: |
          set -euo pipefail
          echo "Iniciando sincronização do ArgoCD…"
          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app get "$ARGOCD_APP" --refresh'

          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app sync "$ARGOCD_APP" --prune --timeout 600'

          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app wait "$ARGOCD_APP" --health --timeout 600'

      # 2) Rollback automático se o passo anterior falhar (mesma lógica já testada)
      - name: Rollback on failure (git revert + Argo CD sync)
        if: steps.argocd-sync.outcome == 'failure'
        env:
          VER: v2.12.3
        run: |
          set -euo pipefail
          echo "⚠️ Deploy falhou — iniciando rollback GitOps…"

          # Garante histórico atualizado
          git fetch origin master
          git checkout master
          git pull --rebase origin master

          # Reverte último commit que alterou a imagem
          LAST_COMMIT=$(git rev-parse HEAD)
          echo "Revertendo commit: ${LAST_COMMIT}"
          git revert --no-edit "${LAST_COMMIT}" || true
          git push

          echo "Sincronizando Argo CD para aplicar o rollback…"
          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app get "$ARGOCD_APP" --refresh'

          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app sync "$ARGOCD_APP" --timeout 600'

          docker run --rm \
            -e ARGOCD_SERVER="$ARGOCD_SERVER" -e ARGOCD_TOKEN="$ARGOCD_TOKEN" -e ARGOCD_APP="$ARGOCD_APP" \
            quay.io/argoproj/argocd:${VER} \
            sh -lc 'argocd --grpc-web --insecure --server "$ARGOCD_SERVER" --auth-token "$ARGOCD_TOKEN" app wait "$ARGOCD_APP" --health --timeout 600'

          echo "✅ Rollback concluído com sucesso."
